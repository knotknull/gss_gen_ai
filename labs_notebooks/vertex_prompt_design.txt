Lab: Generative AI with Vertex AI: Prompt Design 
https://www.cloudskillsboost.google/catalog_lab/6395


## Intro to prompting documentation
https://cloud.google.com/vertex-ai/generative-ai/docs/learn/prompts/introduction-prompt-design


## set environment and libraries
## 
%pip install --upgrade --quiet google-genai

## import libraries
from IPython.display import Markdown, display
from google import genai
from google.genai.types import GenerateContentConfig

## setup cloud project
import os

PROJECT_ID = "[your-project-id]"  # @param {type: "string", placeholder: "[your-project-id]", isTemplate: true}
if not PROJECT_ID or PROJECT_ID == "[your-project-id]":
    PROJECT_ID = str(os.environ.get("GOOGLE_CLOUD_PROJECT"))

LOCATION = os.environ.get("GOOGLE_CLOUD_REGION", "us-central1")

## get client to Vertex AI
client = genai.Client(vertexai=True, project=PROJECT_ID, location=LOCATION)

## set Model
MODEL_ID = "gemini-2.0-flash-001"  # @param {type: "string"}



## Specific and well defined
## 

prompt = "Tell me about Earth"
vs. 
prompt = "Generate a list of ways that makes Earth unique compared to other planets"
response = client.models.generate_content(model=MODEL_ID, contents=prompt)
display(Markdown(response.text))

OUTPUT:

Earth boasts a unique combination of features that, as far as we know, haven't been found on any other planet. Here's a list of those distinguishing characteristics:

Essential for Life (as we know it):

    Liquid Water on the Surface: Abundant and stable liquid water is crucial for the biochemistry that supports life. Most planets are either too hot or too cold for liquid water to exist.
    Oxygen-Rich Atmosphere: While other planets have atmospheres, Earth's atmosphere is unusually rich in free oxygen, largely due to photosynthetic life.
    Stable Temperature: The combination of atmospheric composition, distance from the sun, and internal processes creates a relatively stable temperature range, suitable for liquid water and complex life.
    Presence of Life: Currently, Earth is the only known planet harboring life, making it inherently unique.

Geological & Physical Features:

    Plate Tectonics: Earth's surface is divided into moving plates that interact, creating mountains, volcanoes, earthquakes, and contributing to the carbon cycle. Plate tectonics are crucial for recycling elements and maintaining a habitable environment over long periods.
    Strong Magnetic Field: Generated by the movement of liquid iron in Earth's core, this field deflects harmful solar radiation and cosmic rays, protecting the atmosphere and life on the surface.
    Dynamo Effect: Earth has a molten metallic core, giving rise to a unique dynamo effect that powers its strong magnetic field.
    Large Moon (Relative to Planet Size): The Moon's gravity stabilizes Earth's axial tilt, leading to more predictable seasons and a more stable climate.
    Relatively Fast Rotation: Earth's rotation period leads to day and night cycles that are conducive to life as we know it.

Atmospheric & Climate Related:

    Ozone Layer: A layer in the stratosphere that absorbs most of the Sun's harmful ultraviolet radiation.
    Complex Weather Patterns: Earth exhibits a diverse range of weather patterns influenced by various factors, including ocean currents, atmospheric circulation, and topography.

etc.

## Ask one task at a time
## 

prompt = "What's the best method of boiling water and why is the sky blue?"

response = client.models.generate_content(model=MODEL_ID, contents=prompt)
display(Markdown(response.text))

OUTPUT: 

Okay, let's tackle these two very different questions!

Best Method of Boiling Water

There isn't one single "best" method, as it depends on your priorities and available resources. Here's a breakdown of common methods and their pros/cons:

    Electric Kettle:
        Pros: Extremely fast, energy-efficient (especially kettles with automatic shut-off), convenient, precise temperature control in some models.
        Cons: Requires electricity, less portable than some other methods, can be more expensive upfront.
        Best for: Quick, daily use at home or in an office where electricity is readily available.

    Stovetop Kettle:
        Pros: Simple, relatively inexpensive, works on any stovetop (gas, electric, induction), durable.
        Cons: Slower than electric kettles, requires monitoring to prevent boiling dry, less precise temperature control.
        Best for: General use when you don't need the speed or features of an electric kettle.

    Microwave:
        Pros: Fast (but often uneven heating), convenient for small amounts of water.
        Cons: Can be dangerous (superheated water can explode when disturbed), not energy-efficient, may impart a plastic taste if heated in a plastic container, uneven boiling can cause burns.
        Best for: Small amounts of water in a pinch, but generally not recommended due to safety concerns.

    Over a Fire (Camping/Outdoors):
        Pros: Useful when electricity or a stovetop isn't available, primal feeling.
        Cons: Requires a heat-resistant container, takes longer, less control over the temperature, risk of burns and fire.
        Best for: Camping, hiking, or survival situations.

    Induction Cooktop:
        Pros: Very fast, energy efficient, precise temperature control.
        Cons: Requires induction-compatible cookware, and induction cooktops themselves can be expensive.
        Best for: High-end kitchens where speed and precision are paramount.

In Summary

    Fastest & Most Convenient (Home/Office): Electric Kettle
    Simple & Reliable (Home): Stovetop Kettle
    Emergency Use (Outdoors): Fire
    Not Recommended (generally): Microwave

Why is the sky blue?

The sky is blue due to a phenomenon called Rayleigh scattering. Here's the breakdown:

    Sunlight and the Atmosphere: Sunlight is made up of all the colors of the rainbow. When sunlight enters the Earth's atmosphere, it collides with tiny air molecules (mostly nitrogen and oxygen).

    Scattering of Light: This collision causes the light to scatter in different directions. The amount of scattering depends on the wavelength (color) of the light.

    Rayleigh Scattering: Rayleigh scattering states that shorter wavelengths of light (blue and violet) are scattered much more strongly than longer wavelengths (red and orange). The scattering is inversely proportional to the fourth power of the wavelength (meaning a small change in wavelength makes a big difference in scattering).

    Why Not Violet? Violet is scattered even more than blue. However, the sun emits less violet light than blue, and our eyes are also more sensitive to blue. These two factors combine so that we see the sky as predominantly blue.

    Sunrise/Sunset: At sunrise and sunset, the sunlight has to travel through more of the atmosphere to reach our eyes. This means that more of the blue light has been scattered away before it reaches us. This leaves the longer wavelengths of light (reds, oranges, and yellows) to dominate, which is why we see those colors at those times.

In short: Blue light is scattered more by the Earth's atmosphere than other colors, making the sky appear blue to our eyes.






VS. 

prompt = "What's the best method of boiling water?"

response = client.models.generate_content(model=MODEL_ID, contents=prompt)
display(Markdown(response.text))

OUTPUT:

The "best" method of boiling water depends on your priorities: speed, energy efficiency, convenience, and available resources. Here's a breakdown:

1. Speed:

    Electric Kettle: Generally the fastest. They are designed to boil water quickly and efficiently. They often have automatic shut-off features, making them safe.
    Electric Induction Cooktop with a suitable pot: Can be very fast, often rivaling electric kettles. The heat is directly transferred to the pot, minimizing wasted energy.
    Microwave (in a microwave-safe container): Can be relatively quick for small amounts of water, but it can heat unevenly and has a risk of "superheating" where the water gets hotter than boiling point without actually boiling, which can lead to explosive boiling when disturbed. Not recommended for large volumes.
    Gas Stove: Fast, but can be less efficient than electric kettles or induction.
    Electric Coil/Radiant Cooktop: Slower than gas or induction because the heat needs to transfer through the coil to the pot.

2. Energy Efficiency:

    Electric Kettle: Typically very efficient because they are designed to heat only the amount of water you need.
    Electric Induction Cooktop: Highly efficient as almost all the energy is directly transferred to the pot.
    Gas Stove: Less efficient than electric options because a significant amount of heat escapes into the surrounding air.
    Electric Coil/Radiant Cooktop: Least efficient among modern cooking methods as a lot of heat is lost to the air.
    Microwave: Generally considered less energy-efficient than kettles or stovetops for boiling water, especially for larger amounts.

3. Convenience:

    Electric Kettle: Extremely convenient due to their portability, automatic shut-off, and ease of use.
    Microwave: Convenient for small amounts of water and quick heating.
    Stovetop (any type): Requires more attention as you need to monitor the boiling and turn off the heat manually. However, it allows you to boil large volumes of water.

4. Available Resources:

    Off-Grid/Camping:
        Camp Stove (gas/propane/wood): The best choice if you don't have electricity.
        Fire (with a suitable pot): A classic, but requires skill and is less efficient.
    Electricity Available:
        Electric Kettle: Generally the best option for home use if you have electricity.
        Electric Induction Cooktop: Excellent if you already have one.
        Microwave: A possible option, but less ideal than the others.

Summary Table:
Method 	                Speed 	    Efficiency 	        Convenience 	Considerations
Electric Kettle 	    Fastest 	Highest 	        Highest 	    Requires electricity, designed for boiling water
Induction Cooktop 	    Very Fast 	High 	            High 	        Requires induction-compatible cookware and cooktop
Gas Stove 	            Fast 	    Moderate 	        Moderate 	    Requires gas connection, less efficient than electric
Electric Coil/Radiant 	Slow 	    Low 	            Moderate 	    Least efficient, slower
Microwave 	Relatively  Quick 	    Low to moderate 	High 	        Uneven heating, risk of superheating, best for small amounts
Camp Stove/Fire 	    Varies 	    Low 	            Low 	        For off-grid situations, requires fuel and skill

Recommendations:

    For most people at home: An electric kettle is the best choice due to its speed, efficiency, and convenience.
    If you already have an induction cooktop: Use that with a suitable pot; it's also an excellent choice.
    For camping or situations without electricity: Use a camp stove or a fire with a suitable pot.

Ultimately, the "best" method is the one that best suits your specific needs and circumstances.


prompt = "Why is the sky blue?"

response = client.models.generate_content(model=MODEL_ID, contents=prompt)
display(Markdown(response.text))

OUTPUT:

The sky appears blue due to a phenomenon called Rayleigh scattering. Here's the breakdown:

    Sunlight is made of all colors: White sunlight is actually a mix of all the colors of the rainbow (red, orange, yellow, green, blue, indigo, violet).

    Entering the atmosphere: When sunlight enters the Earth's atmosphere, it collides with tiny air molecules (mostly nitrogen and oxygen).

    Scattering: This collision causes the sunlight to scatter in different directions.

    Rayleigh scattering prefers shorter wavelengths: Rayleigh scattering is much more effective at scattering shorter wavelengths of light. Blue and violet light have shorter wavelengths than other colors like red and orange.

    Blue dominates: Because blue light is scattered about 10 times more efficiently than red light, it gets scattered all over the sky. This is why we see a blue sky when we look up â€“ we are seeing the scattered blue light coming from all directions.

Why not violet?

Violet light has an even shorter wavelength than blue, so you might wonder why the sky isn't violet. There are a few reasons:

    Sunlight isn't equally strong in all colors: The sun emits slightly less violet light than blue light.
    Our eyes are less sensitive to violet: Human eyes are more sensitive to blue light than violet light.
    Atmospheric absorption: The upper atmosphere absorbs some of the violet light.

In summary: The sky is blue because blue light is scattered more effectively by air molecules in the atmosphere than other colors, due to a phenomenon called Rayleigh scattering.



## Watch for hallucinations
## 

generation_config = GenerateContentConfig(temperature=1.0)

prompt = "What day is it today?"

response = client.models.generate_content(model=MODEL_ID, contents=prompt)
display(Markdown(response.text))

OUTPUT: 

Today is Wednesday, November 1, 2023.

NOTE: Since LLMs do not have access to real-time information without further integrations, 
      you may have noticed it hallucinates what day it is today in some of the outputs.


## Guardrails, use system prompts to reduce hallucinations
## 

generation_config = GenerateContentConfig(temperature=1.0)

chat = client.chats.create(
    model=MODEL_ID,
    config=GenerateContentConfig(
        system_instruction=[
            "Hello! You are an AI chatbot for a travel web site.",
            "Your mission is to provide helpful queries for travelers.",
            "Remember that before you answer a question, you must check to see if it complies with your mission.",
            "If not, you can say, Sorry I can't answer that question.",
        ]
    ),
)

prompt = "What is the best place for sightseeing in Milan, Italy?"

response = chat.send_message(prompt)
display(Markdown(response.text))

OUTPUT: 

The best place for sightseeing in Milan, Italy is the Duomo di Milano, the city's iconic cathedral. 
Other popular attractions include the Galleria Vittorio Emanuele II, Teatro alla Scala, and Sforza Castle.



VS.

prompt = "What is the best place for sightseeing in Milan, Italy?"

response = chat.send_message(prompt)
display(Markdown(response.text))


OUTPUT: 

The best place for sightseeing in Milan, Italy is subjective and depends on your interests, but here are a few top recommendations:

    Duomo di Milano: The iconic cathedral is a must-see.

    Galleria Vittorio Emanuele II: A beautiful shopping arcade.

    Teatro alla Scala: Famous opera house.

    Sforza Castle: A historic castle with museums.

(Seems the same to me)


## Turn generative tasks into classifications tasks
## 
Classification reduces variability: 

prompt = "I'm a high school student. Recommend me a programming activity to improve my skills."

response = client.models.generate_content(model=MODEL_ID, contents=prompt)
display(Markdown(response.text))

OUTPUT:  (BEWARE ... HUGE AMOUNT OF TEXT )

Okay, here's a programming activity tailored for a high school student looking to improve their skills, along with variations for different skill levels and interests:

Activity: Text-Based Adventure Game

This project is great because it allows you to practice:

    Basic Input/Output: Taking commands from the user (typing) and displaying text to the screen.
    Conditional Logic (if/else): Determining what happens based on the player's choices.
    Variables: Tracking the player's inventory, health, location, and other game state.
    Functions: Breaking down the game into smaller, manageable pieces (e.g., a function to describe a room, a function to handle combat).
    Data Structures (Lists/Dictionaries): Storing information about the game world (e.g., items in a room, possible exits).
    Loops (while): Keeping the game running until the player wins or loses.

Here's a breakdown of how to approach it, with increasing levels of complexity:

Level 1: Beginner - The Simple Room Explorer

    The Scenario: The player starts in a single room. The goal is to find a specific item or solve a simple puzzle to escape.

    Features:
        Describe the Room: Use print() statements to describe the room and the objects in it.
        Simple Commands: Accept basic commands like "look," "take [item]," "use [item]," "go [direction]".
        Limited Inventory: The player can only carry one or two items.
        Win Condition: The player wins by using the correct item or command to escape the room.
        Language: Python (easiest to learn and set up)

    # Example (Python):

    def describe_room():
        print("You are in a dusty attic.  There's a box in the corner and a window to the north.")

    def main():
        inventory = []
        describe_room()

        while True:
            command = input("> ").lower()

            if command == "look":
                describe_room()
            elif command == "take box":
                print("You take the box.")
                inventory.append("box")
            elif command == "go north" and "box" in inventory:
                print("You use the box to reach the window and escape! You win!")
                break
            elif command == "go north":
                print("You can't reach the window.")
            else:
                print("I don't understand that command.")

    if __name__ == "__main__":
        main()

Level 2: Intermediate - Multiple Rooms and Combat

    The Scenario: The player explores a small map with connected rooms, encountering obstacles and potentially enemies.

    Features:
        Multiple Rooms: Represent rooms as dictionaries, with descriptions, exits, and items.
        Navigation: Implement commands like "go north," "go south," "go east," "go west" to move between rooms.
        Combat: Introduce simple combat with enemies. Use random numbers to determine attack success and damage.
        Health: The player has a health value that decreases during combat.
        Inventory: Allow the player to carry multiple items.
        Language: Python, JavaScript (using the console), or C# (using a console application)

    # Example (Python - Simplified)

    rooms = {
        "attic": {
            "description": "A dusty attic. A trapdoor leads down.",
            "exits": {"down": "cellar"},
            "items": ["key"]
        },
        "cellar": {
            "description": "A dark cellar. A monster lurks in the corner.",
            "exits": {"up": "attic"},
            "monster": "goblin"
        }
    }

    current_room = "attic"
    inventory = []
    health = 10

    def describe_room(room_name):
        print(rooms[room_name]["description"])

    def main():
        global current_room, health
        while health > 0:
            describe_room(current_room)
            command = input("> ").lower()

            if command.startswith("go"):
                direction = command.split(" ")[1]
                if direction in rooms[current_room]["exits"]:
                    current_room = rooms[current_room]["exits"][direction]
                else:
                    print("You can't go that way.")
            elif command == "take key" and "key" in rooms[current_room]["items"]:
                print("You take the key.")
                inventory.append("key")
                rooms[current_room]["items"].remove("key")
            elif command == "attack goblin" and "goblin" in rooms[current_room].get("monster", ""): # using .get to avoid errors when monster is not present
                # (Implement combat logic - simplified for brevity)
                print("You attack the goblin!")
                health -= 3
                print(f"Your health: {health}")
            else:
                print("I don't understand.")

        if health <= 0:
            print("You have died!")

    if __name__ == "__main__":
        main()

Level 3: Advanced - Object-Oriented Design, Story, and More

    The Scenario: A more complex world with a compelling story, multiple quests, and interesting characters.

    Features:
        Object-Oriented Programming (OOP): Create classes for rooms, items, characters, and enemies. This will make your code more organized and reusable.
        Story and Dialogue: Write a more engaging story with dialogue between the player and Non-Player Characters (NPCs).
        Quests: Implement quests that the player can complete to earn rewards.
        More Complex Combat: Include different types of weapons, armor, and special abilities.
        Saving and Loading: Allow the player to save their game progress and load it later.
        Map Generation (Optional): Explore algorithms for generating random map layouts.
        Language: Python, Java, C#, or C++ (if you want a challenge). Consider using a game library like Pygame (for Python) or Unity (for C#) if you want graphics.

    # Example (Python - Conceptual OOP)

    class Room:
        def __init__(self, name, description, exits, items=None):
            self.name = name
            self.description = description
            self.exits = exits
            self.items = items if items else []

        def describe(self):
            print(self.description)

    class Item:
        def __init__(self, name, description, use_action=None):
            self.name = name
            self.description = description
            self.use_action = use_action

        def use(self, player):
            if self.use_action:
                self.use_action(player)
            else:
                print("You can't use that here.")

    # ... (More classes for Player, Enemy, etc.)

    # Example Room
    forest = Room(
        "Forest",
        "A dense forest. Sunlight filters through the trees.",
        {"north": "clearing", "south": "path"}
    )

    # Example Item
    sword = Item(
        "Sword",
        "A sharp steel sword.",
        use_action=lambda player: print("You swing the sword!")  # Example usage
    )

    # ... (Instantiate objects, connect rooms, implement game logic)

How to Get Started:

    Choose a Language: Start with Python if you're a beginner. It's easy to learn.
    Break it Down: Don't try to build the whole game at once. Start with the simplest version and gradually add features.
    Plan Your Game: Think about the story, the characters, the map, and the puzzles before you start coding. A simple flowchart can be helpful.
    Use Resources:
        Online Tutorials: Search for "text-based adventure game tutorial [language]" (e.g., "text-based adventure game tutorial Python").
        Documentation: Learn to read the official documentation for your chosen programming language.
        Stack Overflow: Use Stack Overflow to find answers to specific coding problems.
    Test Frequently: Run your code often to catch errors early.
    Ask for Help: Don't be afraid to ask for help from teachers, mentors, or online communities.

Variations Based on Interests:

    Fantasy: Create a game with magic, dragons, and knights.
    Sci-Fi: Build a game set in space with robots, spaceships, and alien civilizations.
    Mystery: Develop a game where the player has to solve a crime or uncover a secret.
    Horror: Design a game with spooky environments, jump scares, and terrifying monsters.

Key Tips for Success:

    Stay Focused: It's easy to get distracted by new features, but try to complete one feature before moving on to the next.
    Keep it Simple: Don't overcomplicate things. The goal is to learn and have fun.
    Document Your Code: Add comments to your code to explain what it does. This will make it easier to understand and maintain.
    Use Version Control (Git): Learn to use Git and GitHub to track your changes and collaborate with others. (This is a great skill to learn regardless of the project!)

This text-based adventure game project offers a great blend of challenge and creativity. It's a fantastic way to solidify your programming skills and build a portfolio piece. Good luck! Let me know if you have any other questions.


vs. 
## Classification 

prompt = """I'm a high school student. Which of these activities do you suggest and why:
a) learn Python
b) learn JavaScript
c) learn Fortran
"""

response = client.models.generate_content(model=MODEL_ID, contents=prompt)
display(Markdown(response.text))

OUTPUT: 

Okay, let's break down these options and figure out what's best for a high school student:

Recommendation:

My strongest recommendation is a) Learn Python.

Here's why, with comparisons to the other options:

    Python - The Winner for Beginners:
        Ease of Learning: Python is renowned for its clear and readable syntax. It's designed to be beginner-friendly. You can get up and running with basic programming concepts quickly.
        Versatility: Python is used in a vast range of fields:
            Web Development: While not its primary strength, it's used for backend development with frameworks like Django and Flask.
            Data Science and Machine Learning: Python is THE dominant language in this booming field. Libraries like NumPy, Pandas, Scikit-learn, and TensorFlow make data manipulation, analysis, and model building much easier.
            Scripting and Automation: Python excels at automating tasks, making it great for things like file management, system administration, and web scraping.
            Game Development: While not as common as other languages for AAA game development, it's used for scripting and prototyping, especially with libraries like Pygame.
        Large Community and Resources: Python has a HUGE and active community. This means you'll find tons of tutorials, documentation, libraries, and help forums online. If you get stuck, there are plenty of places to find answers.
        Job Market: Python skills are in high demand across various industries.

    JavaScript - A Strong Second Choice:
        Web Development Focus: JavaScript is essential for front-end web development (making websites interactive). It runs directly in the browser.
        Growing Back-End Role: With Node.js, JavaScript can also be used for back-end development. This is a valuable skill.
        More Complex Syntax: JavaScript's syntax can be a bit trickier for beginners than Python's. It has some quirks and subtleties.
        Fast Feedback: You can see the results of your JavaScript code almost immediately in a web browser. This is great for learning.
        Good Job Market: JavaScript is a highly sought-after skill for web developers.
        Recommendation for you: If you know you have an affinity for web development or would like to become a web developer, it's a great choice.

    Fortran - Niche and Less Relevant for Most High School Students:
        Scientific and Engineering Computing: Fortran is a very old language that is still used in specific areas of scientific and engineering computing (e.g., weather forecasting, computational fluid dynamics).
        Performance: Fortran is known for its performance in numerical computations.
        Limited Modern Use: Outside of those niche areas, Fortran is not widely used in modern software development.
        Steeper Learning Curve: Fortran can be more challenging to learn than Python or JavaScript.
        Smaller Community and Fewer Resources: Compared to Python and JavaScript, the Fortran community is much smaller, and there are fewer modern learning resources.
        Recommendation for you: Unless you know you are going into a specific field that uses Fortran, I would suggest avoiding it at this time.

In Summary:

    Python: Best overall choice for versatility, ease of learning, and career opportunities. It's a great starting point for exploring many different areas of computer science.
    JavaScript: Excellent choice if you are interested in web development. It's essential for front-end and increasingly important for back-end web development.
    Fortran: Only consider if you have a specific interest in scientific or engineering computing. It's a niche language with limited general applicability.

Next Steps:

    Start with Python: Find a good introductory Python course (Codecademy, Coursera, edX, freeCodeCamp.org are all good resources). Focus on the basics: variables, data types, loops, functions, and basic data structures (lists, dictionaries).
    Consider JavaScript after Python: Once you have a good grasp of Python fundamentals, you can explore JavaScript if you're interested in web development.

Good luck with your programming journey!






## Improve responses with Examples (i.e. Shots)
## 
The LLM learns in-context from the examples on how to respond. Typically, one to five examples (shots) 
are enough to improve the quality of responses. Including too many examples can cause the model to 
over-fit the data and reduce the quality of responses.


## Zero Shot Prompt (no examples)
## 
prompt = """Decide whether a Tweet's sentiment is positive, neutral, or negative.

Tweet: I loved the new YouTube video you made!
Sentiment:
"""

response = client.models.generate_content(model=MODEL_ID, contents=prompt)
display(Markdown(response.text))

OUTPUT: 
Sentiment: Positive


## One Shot Prompt (no examples)
## 
prompt = """Decide whether a Tweet's sentiment is positive, neutral, or negative.

Tweet: I loved the new YouTube video you made!
Sentiment: positive

Tweet: That was awful. Super boring ðŸ˜ 
Sentiment:
"""

response = client.models.generate_content(model=MODEL_ID, contents=prompt)
display(Markdown(response.text))

OUTPUT:

Sentiment: negative


## Few Shot Prompt (no examples)
## 

prompt = """Decide whether a Tweet's sentiment is positive, neutral, or negative.

Tweet: I loved the new YouTube video you made!
Sentiment: positive

Tweet: That was awful. Super boring ðŸ˜ 
Sentiment: negative

Tweet: Something surprised me about this video - it was actually original. It was not the same old recycled stuff that I always see. Watch it - you will not regret it.
Sentiment:
"""

response = client.models.generate_content(model=MODEL_ID, contents=prompt)
display(Markdown(response.text))

OUTPUT: 

Sentiment: positive

NOTE: 
The zero-shot prompts are more open-ended and can give you creative answers, 
while one-shot and few-shot prompts teach the model how to behave so you can get more predictable 
answers that are consistent with the examples provided.


## Vertex AI Generative Cookbooks
## 
https://cloud.google.com/vertex-ai/generative-ai/docs/cookbook








################################################################3# 
## Now for something completely different
## Running starlite in a Jupyter Notebook
################################################################3# 

1. install starlite
    pip install starlite

2. write starlite app

# app.py
from starlite import Starlite, get

@get("/")
def hello_world() -> dict:
    return {"message": "Hello, world!"}

app = Starlite(route_handlers=[hello_world])


3. Run the app using uvicorn

%run app.py
import uvicorn
import asyncio

if __name__ == "__main__":
    asyncio.create_task(uvicorn.run("app:app", host="0.0.0.0", port=8000))


4. Open another notebook cell and use requests (or similar) to make 
   requests against running Starlite app

import requests
response = requests.get("http://localhost:8000")
print(response.json())









.